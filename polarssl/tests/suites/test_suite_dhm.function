/* BEGIN_HEADER */
#include <polarssl/dhm.h>
/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:POLARSSL_DHM_C:POLARSSL_BIGNUM_C
 * END_DEPENDENCIES
 */

/* BEGIN_CASE */
void dhm_do_dhm( int radix_P, char *input_P,
                 int radix_G, char *input_G )
{
    dhm_context ctx_srv;
    dhm_context ctx_cli;
    unsigned char ske[1000];
    unsigned char *p = ske;
    unsigned char pub_cli[1000];
    unsigned char sec_srv[1000];
    unsigned char sec_cli[1000];
    size_t ske_len = 0;
    size_t pub_cli_len = 0;
    size_t sec_srv_len = 1000;
    size_t sec_cli_len = 1000;
    int x_size, i;
    rnd_pseudo_info rnd_info;

    memset( &ctx_srv, 0x00, sizeof( dhm_context ) );
    memset( &ctx_cli, 0x00, sizeof( dhm_context ) );
    memset( ske, 0x00, 1000 );
    memset( pub_cli, 0x00, 1000 );
    memset( sec_srv, 0x00, 1000 );
    memset( sec_cli, 0x00, 1000 );
    memset( &rnd_info, 0x00, sizeof( rnd_pseudo_info ) );

    /*
     * Set params
     */
    TEST_ASSERT( mpi_read_string( &ctx_srv.P, radix_P, input_P ) == 0 );
    TEST_ASSERT( mpi_read_string( &ctx_srv.G, radix_G, input_G ) == 0 );
    x_size = mpi_size( &ctx_srv.P );
    pub_cli_len = x_size;

    /*
     * First key exchange
     */
    TEST_ASSERT( dhm_make_params( &ctx_srv, x_size, ske, &ske_len, &rnd_pseudo_rand, &rnd_info ) == 0 );
    ske[ske_len++] = 0;
    ske[ske_len++] = 0;
    TEST_ASSERT( dhm_read_params( &ctx_cli, &p, ske + ske_len ) == 0 );

    TEST_ASSERT( dhm_make_public( &ctx_cli, x_size, pub_cli, pub_cli_len, &rnd_pseudo_rand, &rnd_info ) == 0 );
    TEST_ASSERT( dhm_read_public( &ctx_srv, pub_cli, pub_cli_len ) == 0 );

    TEST_ASSERT( dhm_calc_secret( &ctx_srv, sec_srv, &sec_srv_len, &rnd_pseudo_rand, &rnd_info ) == 0 );
    TEST_ASSERT( dhm_calc_secret( &ctx_cli, sec_cli, &sec_cli_len, NULL, NULL ) == 0 );

    TEST_ASSERT( sec_srv_len == sec_cli_len );
    TEST_ASSERT( sec_srv_len != 0 );
    TEST_ASSERT( memcmp( sec_srv, sec_cli, sec_srv_len ) == 0 );

    /* Re-do calc_secret on server a few times to test update of blinding values */
    for( i = 0; i < 3; i++ )
    {
        sec_srv_len = 1000;
        TEST_ASSERT( dhm_calc_secret( &ctx_srv, sec_srv, &sec_srv_len, &rnd_pseudo_rand, &rnd_info ) == 0 );

        TEST_ASSERT( sec_srv_len == sec_cli_len );
        TEST_ASSERT( sec_srv_len != 0 );
        TEST_ASSERT( memcmp( sec_srv, sec_cli, sec_srv_len ) == 0 );
    }

    /*
     * Second key exchange to test change of blinding values on server
     */
    sec_cli_len = 1000;
    sec_srv_len = 1000;
    p = ske;

    TEST_ASSERT( dhm_make_params( &ctx_srv, x_size, ske, &ske_len, &rnd_pseudo_rand, &rnd_info ) == 0 );
    ske[ske_len++] = 0;
    ske[ske_len++] = 0;
    TEST_ASSERT( dhm_read_params( &ctx_cli, &p, ske + ske_len ) == 0 );

    TEST_ASSERT( dhm_make_public( &ctx_cli, x_size, pub_cli, pub_cli_len, &rnd_pseudo_rand, &rnd_info ) == 0 );
    TEST_ASSERT( dhm_read_public( &ctx_srv, pub_cli, pub_cli_len ) == 0 );

    TEST_ASSERT( dhm_calc_secret( &ctx_srv, sec_srv, &sec_srv_len, &rnd_pseudo_rand, &rnd_info ) == 0 );
    TEST_ASSERT( dhm_calc_secret( &ctx_cli, sec_cli, &sec_cli_len, NULL, NULL ) == 0 );

    TEST_ASSERT( sec_srv_len == sec_cli_len );
    TEST_ASSERT( sec_srv_len != 0 );
    TEST_ASSERT( memcmp( sec_srv, sec_cli, sec_srv_len ) == 0 );

    dhm_free( &ctx_srv );
    dhm_free( &ctx_cli );
}
/* END_CASE */

/* BEGIN_CASE depends_on:POLARSSL_SELF_TEST */
void dhm_selftest()
{
    TEST_ASSERT( dhm_self_test( 0 ) == 0 );
}
/* END_CASE */
